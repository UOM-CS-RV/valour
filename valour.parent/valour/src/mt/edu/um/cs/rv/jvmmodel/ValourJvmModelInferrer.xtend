/*
 * generated by Xtext 2.9.2
 */
package mt.edu.um.cs.rv.jvmmodel

import com.google.inject.Inject
import java.util.HashMap
import mt.edu.um.cs.rv.valour.ActionBlock
import mt.edu.um.cs.rv.valour.ActualParameters
import mt.edu.um.cs.rv.valour.AdditionalTrigger
import mt.edu.um.cs.rv.valour.BasicRule
import mt.edu.um.cs.rv.valour.CategorisationClause
import mt.edu.um.cs.rv.valour.Category
import mt.edu.um.cs.rv.valour.ConditionBlock
import mt.edu.um.cs.rv.valour.ConditionExpression
import mt.edu.um.cs.rv.valour.ConditionRefInvocation
import mt.edu.um.cs.rv.valour.Declarations
import mt.edu.um.cs.rv.valour.EventBody
import mt.edu.um.cs.rv.valour.ForEach
import mt.edu.um.cs.rv.valour.FormalParameters
import mt.edu.um.cs.rv.valour.Model
import mt.edu.um.cs.rv.valour.ParForEach
import mt.edu.um.cs.rv.valour.Rule
import mt.edu.um.cs.rv.valour.Rules
import mt.edu.um.cs.rv.valour.SimpleTrigger
import mt.edu.um.cs.rv.valour.StateBlock
import mt.edu.um.cs.rv.valour.StateDeclaration
import mt.edu.um.cs.rv.valour.ValourBody
import mt.edu.um.cs.rv.valour.ValueExpression
import mt.edu.um.cs.rv.valour.WhenClause
import mt.edu.um.cs.rv.valour.WhereClauses
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.xbase.XExpression
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor.IPostIndexingInitializing
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.eclipse.xtext.xtype.XImportSection
import mt.edu.um.cs.rv.valour.Condition
import org.eclipse.xtext.xbase.jvmmodel.JvmTypeReferenceBuilder
import org.eclipse.xtext.common.types.JvmVisibility
import org.eclipse.xtext.xbase.XBlockExpression
import mt.edu.um.cs.rv.valour.Action

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class ValourJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the closure you pass to the returned
	 *            {@link IPostIndexingInitializing#initializeLater(org.eclipse.xtext.xbase.lib.Procedures.Procedure1)
	 *            initializeLater(..)}.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(Model element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		// Here you explain how your model is mapped to Java elements, by writing the actual translation code.
		// An implementation for the initial hello world example could look like this:
//   		acceptor.accept(element.toClass("my.company.greeting.MyGreetings")) [
//   			for (greeting : element.greetings) {
//   				members += greeting.toMethod("hello" + greeting.name, typeRef(String)) [
//   					body = '''
//							return "Hello «greeting.name»";
//   					'''
//   				]
//   			}
//   		]

		if (!isPreIndexingPhase) {
			
			
			//TODO the package to which to generate the classes should be defined in the language
			val packageName = packageNameToUse(element.eResource.URI.lastSegment)
			
			//TODO rename?
			val String scaffoldClassName = packageName+".Scaffold"
			var JvmGenericType scaffoldClass = element.toClass(scaffoldClassName)
			scaffoldClass.members += element.toClass("Categories", [static = true])
			scaffoldClass.members += element.toClass("Conditions", [static = true])
			scaffoldClass.members += element.toClass("Actions", [static = true])
					
			acceptor.accept(
					scaffoldClass
			)
			
			//add categories nested class
//			scaffoldClass.

			// handle imports
			if (element.imports != null){
				handleImports(element.imports)
			}
			
			handleValourBody(element.body, scaffoldClass)
		}
	}
	
	def String packageNameToUse(String inputFileName){
		val lastIndex = inputFileName.lastIndexOf('.valour')
		if (lastIndex > 0)
		{
			return "valour." + inputFileName.substring(0, lastIndex)
		}
		else{
			return "valour." + inputFileName.toLowerCase
		}
		
	}
	
	def void handleImports(XImportSection imports){
		for (i : imports.importDeclarations) {
				println('import ' + i.importedName)
			}
	}

	def void handleValourBody(ValourBody vb, JvmGenericType scaffoldClass) {
		// handle declarations
		if (vb.declarations != null) {
			handleDeclarations(vb.declarations, scaffoldClass)
		}

		// handle rules
		if (vb.rules != null) {
			handleRules(vb.rules)
		}
	}

	def void handleDeclarations(Declarations declarations, JvmGenericType scaffoldClass) {
		if (declarations.declarations != null && declarations.declarations.length > 0) {
			println("declarations {")
			for (d : declarations.declarations) {
				if (d.category != null) {
					handleCategoryDeclaration(d.category, scaffoldClass)
				} else if (d.event != null) {
					print('event ' + d.event.name + ' (')
					handleFormalParameters(d.event.eventFormalParameters)
					println(') = {')
					handleEventBody(d.event.eventBody)
					println('}')
				} else if (d.condition != null) {
					handleConditionDeclaration(d.condition, scaffoldClass)
				} else if (d.action != null) {
					handleActionDeclaration(d.action, scaffoldClass)
				}
			}
			println("}")
			println
		}
	}
	
	def void handleCategoryDeclaration(Category category, JvmGenericType scaffoldClass){
		println('category ' + category.name + ' indexed by ' + category.keyType.qualifiedName)
		
		val categoriesClass = scaffoldClass.findAllNestedTypesByName("Categories").findFirst[true]
		
		categoriesClass.members += category.toField(category.name, typeRef(HashMap, category.keyType, typeRef(Object)))
		categoriesClass.members += category.toGetter(category.name, typeRef(HashMap, category.keyType, typeRef(Object)))
		 
	}
	
	def void handleConditionDeclaration(Condition condition, JvmGenericType scaffoldClass){
		print('condition ' + condition.name + ' (')
		handleFormalParameters(condition.conditionFormalParameters)
		print(') = ')
		handleConditionExpression(condition.conditionExpression)
		println()
		
		val conditionsClass = scaffoldClass.findAllNestedTypesByName("Conditions").findFirst[true]	
		conditionsClass.members += 
			condition.toMethod(condition.name, 
								typeRef(Boolean), 
								[
									static = true
									visibility = JvmVisibility.PUBLIC
									for (p : condition.conditionFormalParameters.parameters) {
							            parameters += p.toParameter(p.name, p.parameterType)
							        }
							        		
									body = handleConditionExpression(condition.conditionExpression)							
								]
							)
	}
	
	def void handleActionDeclaration(Action action, JvmGenericType scaffoldClass){
		print('action ' + action.name + ' (')
		handleFormalParameters(action.actionFormalParameters)
		print(') = ')
		handleActionBlock(action.action as ActionBlock)  //TODO not sure whether there is a better way of doing this (i.e. not with a type cast)
		println
		
		val actionsClass = scaffoldClass.findAllNestedTypesByName("Actions").findFirst[true]	
		actionsClass.members += 
			action.toMethod(action.name, 
								typeRef(void), 
								[
									static = true
									visibility = JvmVisibility.PUBLIC
									for (p : action.actionFormalParameters.parameters) {
							            parameters += p.toParameter(p.name, p.parameterType)
							        }
							        		
									body = handleActionBlock(action.action as ActionBlock)							
								]
							)
	}

	def void handleFormalParameters(FormalParameters fps) {
		if (fps != null) {
			var fpsSize = fps.parameters.length
			for (fp : fps.parameters) {
				print(fp.parameterType.qualifiedName + ' ' + fp.name)
				fpsSize--;
				if (fpsSize > 0) {
					print(', ')
				}
			}
		}
	}

	def void handleActualParameters(ActualParameters aps) {
		if (aps != null) {
			var apsSize = aps.parameters.length
			for (ap : aps.parameters) {
				print(ap.toString)
				apsSize--;
				if (apsSize > 0) {
					print(', ')
				}
			}
		}
	}

	def void handleEventBody(EventBody eventBody) {
		handleSimpleTrigger(eventBody.trigger)
		if (eventBody.additionalTrigger != null) {
			handleAdditionalTrigger(eventBody.additionalTrigger)
		}

		if (eventBody.where != null) {
			handleWhereClauses(eventBody.where)
		}

		if (eventBody.when != null) {
			handleWhen(eventBody.when)
		}

		if (eventBody.categorisation != null) {
			handleCategorisation(eventBody.categorisation)
		}
	}

	def void handleSimpleTrigger(SimpleTrigger simpleTrigger) {
		if (simpleTrigger.controlFlowTrigger != null) {
			println('system controlflow trigger \"' + simpleTrigger.controlFlowTrigger.aop.expression + '\"')
		} else if (simpleTrigger.eventTrigger != null) {
			print('event trigger ' + simpleTrigger.eventTrigger.onEvent + ' (')
			handleFormalParameters(simpleTrigger.eventTrigger.params)
			println(')')
		} else if (simpleTrigger.monitorTrigger != null) {
			print('monitor trigger ' + simpleTrigger.monitorTrigger.name + ' (')
			handleFormalParameters(simpleTrigger.monitorTrigger.params)
			println(')')
		}

		if (simpleTrigger.whereClauses != null) {
			handleWhereClauses(simpleTrigger.whereClauses)
		}
	}

	def void handleAdditionalTrigger(AdditionalTrigger additionalTrigger) {
		println()
		print('\t|| ')
		handleSimpleTrigger(additionalTrigger.trigger)

		if (additionalTrigger.additionalTrigger != null) {
			handleAdditionalTrigger(additionalTrigger.additionalTrigger)
		}
	}

	def void handleWhereClauses(WhereClauses whereClauses) {
		print('where ')
		for (clause : whereClauses.clauses) {
			print(clause.whereId + " = ")
			handleValueExpression(clause.whereExpression)
		}
		println
	}

	def void handleWhen(WhenClause whenClause) {
		print('when ')
		handleConditionExpression(whenClause.condition)
		println
	}

	def void handleCategorisation(CategorisationClause cc) {
		print('belonging to ' + cc.category.name + ' with index ')
		handleValueExpression(cc.categoryExpression)
		println
	}

	def void handleValueExpression(ValueExpression ve) {
	
		if (ve.simple != null){
			handleValueBlockStatements('{{', '}}', ve.simple.expressions)
		}
		else {
			handleValueBlockStatements('{', '}', ve.complex.expressions)
		}
	}
	
	def handleValueBlockStatements(String openBraces, String closeBraces, EList<XExpression> expressions) {
		println(openBraces)
		for (e : expressions){
			println(NodeModelUtils.getNode(e).text)
		}
		println(closeBraces)
	}

	def XBlockExpression handleConditionExpression(ConditionExpression ce) {
		if (ce.ref != null){
			handleConditionRefInvocation(ce.ref)
			//TODO
			return null
		}
		else{
			return handleConditionBlock(ce.block)
		}
	}
	
	def void handleConditionRefInvocation(ConditionRefInvocation cri){
		print('#' + cri.ref.ref.name + '(')
		handleActualParameters(cri.params)
		print(')')
	}
	
	def XBlockExpression handleConditionBlock(ConditionBlock cb){
		if (cb.simple != null){
			handleConditionBlockStatements('{{', '}}', cb.simple.expressions)
			return cb.simple
		}
		else {
			handleConditionBlockStatements('{', '}', cb.complex.expressions)
			return cb.complex
		}
	}
	
	def handleConditionBlockStatements(String openBraces, String closeBraces, EList<XExpression> expressions) {
		println(openBraces)
		for (e : expressions){
			//TODO check whether ConditionRefInvocation is being handled correctly
			println(NodeModelUtils.getNode(e).text)
		}
		println(closeBraces)
	}

	def XBlockExpression handleActionBlock(ActionBlock ab) {
		println('{')
		for (e : ab.expressions){
			//TODO check whether ActionRefInvocation is being handled correctly
			println(NodeModelUtils.getNode(e).text)
		}
		println('}')
		
		return ab
	}

	def void handleRules(Rules rules) {
		for (rule : rules.rules) {
			handleRule(rule)
		}
	}

	def void handleRule(Rule rule) {
		if (rule.basicRule != null) {
			handleBasicRule(rule.basicRule)
		}

		if (rule.stateBlock != null) {
			handleStateBlock(rule.stateBlock)
		}

		if (rule.forEach != null) {
			handleForEach(rule.forEach)
		}

		if (rule.parForEach != null) {
			handleParForEach(rule.parForEach)
		}
		println()
	}

	def void handleBasicRule(BasicRule br) {
		print(br.event.eventRefId.name + "(")
		handleActualParameters(br.event.eventActualParameters)
		print(") ")

		if (br.condition != null) {
			print(' | ')
			handleConditionExpression(br.condition)
		}

		print(' -> ')

		val ra = br.ruleAction

		if (ra.actionBlock != null) {
			handleActionBlock(ra.actionBlock as ActionBlock)
		} else if (ra.actionRefInvocation != null) {
			print('#')
			print(ra.actionRefInvocation.actionRef.actionRefId.name)
			print('(')
			handleActualParameters(ra.actionRefInvocation.actionActualParameters)
			println(')')
		} else {
			// action monitor trigger fire
			print('#generate trigger')
			print(ra.actionMonitorTriggerFire.monitorTrigger)
			print('(')
			handleActualParameters(ra.actionMonitorTriggerFire.monitorTriggerActualParameters)
			println(')')
		}

	}

	def handleStateBlock(StateBlock sb) {
		println('state {')
		for (sd : sb.stateDec) {
			handleStateDeclaration(sd)
		}
		println('} in {')
		handleValourBody(sb.valourBody, null)
		println('}')

	}

	def handleStateDeclaration(StateDeclaration sd) {
		print(sd.type.qualifiedName + ' ')
		print(sd.name + ' = ')
		handleValueExpression(sd.valueExpression)
		println
	}

	def handleForEach(ForEach fe) {
		println('replicate {')
		for (sd : fe.stateDec) {
			handleStateDeclaration(sd)
		}
		println('} foreach ' + fe.category.name + ' ' + fe.categoryLabel + '{ ')
		handleValourBody(fe.valourBody, null)
		println('}')
	}

	def handleParForEach(ParForEach pfe) {
		println('replicate in parallel {')
		for (sd : pfe.stateDec) {
			handleStateDeclaration(sd)
		}
		println('} foreach ' + pfe.category.name + ' ' + pfe.categoryLabel + '{ ')
		handleValourBody(pfe.valourBody, null)
		println('}')
	}

}
